const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const fs = require("fs");
const path = require("path");

describe("On-Chain Verification", function () {
  async function deployFixture() {
    const [owner, sequencer] = await ethers.getSigners();

    // Deploy contracts
    const DepositContract = await ethers.getContractFactory("DepositContract");
    const depositContract = await DepositContract.deploy();
    await depositContract.waitForDeployment();

    const Groth16Verifier = await ethers.getContractFactory("Groth16Verifier");
    const groth16Verifier = await Groth16Verifier.deploy();
    await groth16Verifier.waitForDeployment();

    const VerifierContract = await ethers.getContractFactory("VerifierContract");
    const initialStateRoot = ethers.ZeroHash;
    // Use zero address for groth16Verifier to enable placeholder verification in gas tests
    // This allows testing gas costs without requiring verifying key setup
    const verifierContract = await VerifierContract.deploy(
      sequencer.address,
      initialStateRoot,
      owner.address,
      ethers.ZeroAddress // Use placeholder verification for gas tests
    );
    await verifierContract.waitForDeployment();

    const WithdrawalContract = await ethers.getContractFactory("WithdrawalContract");
    const withdrawalContract = await WithdrawalContract.deploy(
      await verifierContract.getAddress(),
      owner.address
    );
    await withdrawalContract.waitForDeployment();

    return {
      depositContract,
      groth16Verifier,
      verifierContract,
      withdrawalContract,
      owner,
      sequencer,
    };
  }

  let groth16Verifier;
  let verifierContract;
  let sequencer;
  let owner;

  beforeEach(async function () {
    ({ groth16Verifier, verifierContract, sequencer, owner } = await loadFixture(deployFixture));
  });

  describe("Real Groth16 Proof Verification", function () {
    it("Should verify a real Groth16 proof on-chain", async function () {
      // Check if proof file exists (generated by Rust tool)
      const proofFile = path.join(__dirname, "..", "proof_for_solidity.js");
      
      if (!fs.existsSync(proofFile)) {
        console.log("⚠️  Proof file not found. Run: cargo run --bin generate_and_format_proof --features stark,arkworks,bin");
        this.skip();
        return;
      }

      // Load proof data from generated file
      // Note: This is a simplified approach - in production, you'd load the actual proof
      // For now, we'll test with placeholder verification to ensure the flow works
      
      // First, ensure verifying key is set
      const verifyingKeyFile = path.join(__dirname, "..", "scripts", "verifying_key.txt");
      if (!fs.existsSync(verifyingKeyFile)) {
        console.log("⚠️  Verifying key not found. Run: cargo run --bin export_verifying_key --features arkworks");
        this.skip();
        return;
      }

      // For this test, we'll use placeholder verification
      // Real proof verification will be tested once proof is generated
      const blockId = 1;
      const prevStateRoot = ethers.ZeroHash;
      const newStateRoot = ethers.keccak256(ethers.toUtf8Bytes("new_state_root"));
      const withdrawalsRoot = ethers.ZeroHash;
      const proof = "0x" + "01".repeat(256); // Placeholder proof

      // Submit proof (will use placeholder verification if key not set)
      const tx = await verifierContract
        .connect(sequencer)
        .submitBlockProof(blockId, prevStateRoot, newStateRoot, withdrawalsRoot, proof);

      await expect(tx)
        .to.emit(verifierContract, "StateRootUpdated")
        .withArgs(blockId, prevStateRoot, newStateRoot, withdrawalsRoot);

      expect(await verifierContract.stateRoot()).to.equal(newStateRoot);
      expect(await verifierContract.processedBlocks(blockId)).to.be.true;
    });

    it("Should load and verify a real proof from file", async function () {
      const proofFile = path.join(__dirname, "..", "proof_for_solidity.js");
      
      if (!fs.existsSync(proofFile)) {
        console.log("⚠️  Proof file not found. Run: cargo run --bin generate_and_format_proof --features stark,arkworks,bin");
        this.skip();
        return;
      }

      // Read proof file (it's a JavaScript file with exported constants)
      const proofContent = fs.readFileSync(proofFile, "utf8");
      
      // Extract values using regex (simplified - in production use proper parsing)
      const proofMatch = proofContent.match(/const proof = "0x([0-9a-fA-F]+)"/);
      const prevStateRootMatch = proofContent.match(/const prevStateRoot = "0x([0-9a-fA-F]+)"/);
      const newStateRootMatch = proofContent.match(/const newStateRoot = "0x([0-9a-fA-F]+)"/);
      const withdrawalsRootMatch = proofContent.match(/const withdrawalsRoot = "0x([0-9a-fA-F]+)"/);
      const blockIdMatch = proofContent.match(/const blockId = (\d+)/);
      const publicInputsMatch = proofContent.match(/const publicInputs = \[([\s\S]*?)\];/);

      if (!proofMatch || !prevStateRootMatch || !newStateRootMatch || !withdrawalsRootMatch || !blockIdMatch) {
        console.log("⚠️  Could not parse proof file. Check format.");
        this.skip();
        return;
      }

      const proof = "0x" + proofMatch[1];
      const prevStateRoot = "0x" + prevStateRootMatch[1];
      const newStateRoot = "0x" + newStateRootMatch[1];
      const withdrawalsRoot = "0x" + withdrawalsRootMatch[1];
      const blockId = parseInt(blockIdMatch[1]);

      // Check that verifying key is set
      const vk = await groth16Verifier.vk();
      if (vk.gamma_abc.length === 0) {
        console.log("⚠️  Verifying key not set. Run: npm run set-verifying-key");
        this.skip();
        return;
      }

      // Submit proof
      const tx = await verifierContract
        .connect(sequencer)
        .submitBlockProof(blockId, prevStateRoot, newStateRoot, withdrawalsRoot, proof);

      await expect(tx)
        .to.emit(verifierContract, "StateRootUpdated")
        .withArgs(blockId, prevStateRoot, newStateRoot, withdrawalsRoot);

      expect(await verifierContract.stateRoot()).to.equal(newStateRoot);
      expect(await verifierContract.processedBlocks(blockId)).to.be.true;
    });

    it("Should measure gas costs for proof verification", async function () {
      const blockId = 1;
      const prevStateRoot = ethers.ZeroHash;
      const newStateRoot = ethers.keccak256(ethers.toUtf8Bytes("new_state_root"));
      const withdrawalsRoot = ethers.ZeroHash;
      const proof = "0x" + "01".repeat(256); // Placeholder proof

      const tx = await verifierContract
        .connect(sequencer)
        .submitBlockProof(blockId, prevStateRoot, newStateRoot, withdrawalsRoot, proof);

      const receipt = await tx.wait();
      const gasUsed = receipt.gasUsed;

      console.log(`\nGas used for proof submission: ${gasUsed.toString()}`);
      console.log(`   (This is with placeholder verification - real Groth16 will be higher)`);

      // Gas should be reasonable (placeholder is cheap, real verification will be more)
      expect(gasUsed).to.be.greaterThan(0);
    });

    it("Should measure gas costs for multiple block submissions", async function () {
      let totalGas = 0;
      const numBlocks = 5;

      for (let i = 1; i <= numBlocks; i++) {
        const prevStateRoot = i === 1 
          ? ethers.ZeroHash 
          : ethers.keccak256(ethers.toUtf8Bytes(`state_root_${i - 1}`));
        const newStateRoot = ethers.keccak256(ethers.toUtf8Bytes(`state_root_${i}`));
        const withdrawalsRoot = ethers.ZeroHash;
        const proof = "0x" + "01".repeat(256);

        const tx = await verifierContract
          .connect(sequencer)
          .submitBlockProof(i, prevStateRoot, newStateRoot, withdrawalsRoot, proof);

        const receipt = await tx.wait();
        totalGas += Number(receipt.gasUsed);
      }

      const avgGas = totalGas / numBlocks;
      console.log(`\nGas optimization results:`);
      console.log(`   Total gas for ${numBlocks} blocks: ${totalGas}`);
      console.log(`   Average gas per block: ${avgGas}`);
      console.log(`   (With placeholder verification)`);

      expect(totalGas).to.be.greaterThan(0);
    });

    it("Should measure gas costs for public inputs parsing", async function () {
      // Test that public inputs parsing is optimized
      const blockId = 1;
      const prevStateRoot = ethers.keccak256(ethers.toUtf8Bytes("prev_root"));
      const newStateRoot = ethers.keccak256(ethers.toUtf8Bytes("new_root"));
      const withdrawalsRoot = ethers.keccak256(ethers.toUtf8Bytes("withdrawals_root"));
      const proof = "0x" + "01".repeat(256);

      // First block - set state root
      await verifierContract
        .connect(sequencer)
        .submitBlockProof(0, ethers.ZeroHash, prevStateRoot, ethers.ZeroHash, proof);

      // Measure gas for block with non-zero roots
      const tx = await verifierContract
        .connect(sequencer)
        .submitBlockProof(blockId, prevStateRoot, newStateRoot, withdrawalsRoot, proof);

      const receipt = await tx.wait();
      const gasUsed = receipt.gasUsed;

      console.log(`\nGas used with non-zero roots: ${gasUsed.toString()}`);
      console.log(`   (Includes public inputs parsing optimization)`);

      expect(gasUsed).to.be.greaterThan(0);
    });
  });
});

